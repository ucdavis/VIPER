@Library('AdminAppsSharedLibraryDev') _
def copyOperations = [
	[
		source: ".\\web\\bin\\Release\\net8.0\\publish",
		testDestination: "%vipertestnet%",
		prodDestination: "%viperprodnet%",
		includeFiles: "*.*",
		excludeFiles: "",
		excludeDirectories: ""
	]

]
def copyOfflineOperations = [
	[
		source: ".",
		testDestination: "%vipertestnet%",
		prodDestination: "%viperprodnet%",
		includeFiles: "app_offline.htm",
		excludeFiles: "",
		excludeDirectories: ""
	]

]
pipeline {
    agent any
	tools { nodejs "NodeJS 20.19.4" }
    options {
        skipStagesAfterUnstable()
        skipDefaultCheckout()
    }
    stages {
        stage('Clean Previous Build') {
		  steps {
			checkout([$class: 'GitSCM',
				branches: scm.branches,
				extensions: [],
				userRemoteConfigs: scm.userRemoteConfigs])
			script {
				if (params.ClearCache) {
					echo 'ClearCache enabled - performing full clean (including node_modules)'
					bat 'git reset --hard && git clean -fdx'
				} else {
					echo 'Preserving caches (node_modules with .tsbuildinfo inside)'
					bat 'git reset --hard && git clean -fdx -e VueApp/node_modules/'
				}
			}
		  }
		}
        stage('Restore packages') {
		  steps {
			script {
				parallel(
					npm: {
						bat 'pushd VueApp && npm install --prefer-offline --no-audit --no-fund && popd'
						bat 'npm audit --prefix VueApp --audit-level=high'
					},
					dotnet: {
						bat '"C:\\Program Files\\dotnet\\dotnet" restore Viper.sln'
					}
				)
			}
		  }
		}
		stage('Build for test') {
			when {
				expression { params.Branch == 'development' }
			}
			steps {
				bat 'npm run --prefix VueApp build-test'
				bat '"C:\\Program Files\\dotnet\\dotnet" publish ./web/Viper.csproj -c "Release" /p:EnvironmentName=Test --nologo -v:minimal'
			}
		}
		stage('Build for prod') {
			when {
				expression { params.Branch == 'master' || params.Branch == "main" }
			}
			steps {
				bat 'npm run --prefix VueApp build'
				bat '"C:\\Program Files\\dotnet\\dotnet" publish ./web/Viper.csproj -c "Release" /p:EnvironmentName=Production --nologo -v:minimal'
			}
		}
		stage('Tests') {
			steps {
                bat 'type NUL > app_offline.htm'
				script {
					parallel(
						backend: {
							bat '"C:\\Program Files\\dotnet\\dotnet" test ./test/Viper.test.csproj -e Test --logger "junit" --configuration release --nologo'
						},
						frontend: {
							bat 'npm run --prefix VueApp test:run'
						}
					)
				}
            }
		}
		stage('Deploy to test') {
			environment {
				NETWORK_SHARE_CRED = credentials('ViperNetworkShare')
			}
			when {
				expression { params.Branch == 'development' }
			}
			steps {
				networkShares()
				filecopy copyOfflineOperations, 'test', env.WORKSPACE
				filecopy copyOperations, 'test', env.WORKSPACE
			}
		}
		stage('Deploy to prod') {
			environment {
				NETWORK_SHARE_CRED = credentials('ViperNetworkShare')
			}
			when {
				expression { params.Branch == 'master' || params.Branch == "main" }
			}
			steps {
				networkShares()
				filecopy copyOfflineOperations, 'prod', env.WORKSPACE
				filecopy copyOperations, 'prod', env.WORKSPACE
			}
		}
    }
	post {
		always {
			//Run junit on the test report to build output
			script {
				if(fileExists('test/TestResults/TestResults.xml')) {
					junit testResults: 'test/TestResults/TestResults.xml', skipPublishingChecks: true
				}
			}

			//Archive the artifacts - in this case, all files - so that the restore job can re-deploy them.
			archiveArtifacts artifacts: 'web/bin/Release/net8.0/publish/**/*', fingerprint: true, onlyIfSuccessful: true
		}
	}
}
